# Java Memory Model

JMM java内存模型

## 为什么要有JMM?

​	了解JMM之前，需要回顾一下计算机系统的内容。

> **北桥芯片与南桥芯片**
>
> ​	南桥芯片是主板芯片组的重要组成部分，负责I/O总线之间的通信。
>
> ​	北桥芯片位置上更靠近CPU，是主板芯片组中起主导作用的最重要的组成部分，负责与CPU的联系并控制内存

### **计算机硬件存储系统**

​	可以分为寄存器，CPU一二三级缓存,主存，本地磁盘，网络。自底向上，运行速度越来越快。

![image-20231121113257920](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211133024.png)

由任务管理器中可以看到，CPU中包含一级缓存、二级缓存、三级缓存，容量大小逐级递增，其基准频率为2.30GHz。

<img src="https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211135998.png" alt="image-20231121113537955" style="zoom: 50%;" />

内存频率为3733MHz，1000MHz = 1GHz，由此对比，3.733GHz > 2.30GHz,内存的速度似乎要比CPU的更快。

<img src="https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211143922.png" alt="image-20231121114323878" style="zoom: 50%;" />

那么一个问题随之抛出，一般来说，CPU运算速度较快，而内存读写速度跟不上时，CPU就可以将这些数据临时存储在缓存中，来缓解CPU的运算速度与内存条读写速度不匹配的矛盾。但是此时内存的速度似乎快于CPU，那么CPU缓存的存在还有意义吗？

​	正好知乎上有类似的疑惑，找到如下回答：

![image-20231121131938239](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211319288.png)

以DDR4为例，可以看到DDR4内存等效频率为3200MHz，而其核心频率为200MHz。而CPU的核心频率则可以达到几千MHz，远高于DDR内存的核心频率。同时DDR的延迟也高于CPU。

![image-20231121132104508](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211321534.png)

![image-20231121132457514](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211324663.png)

​	答主用两根DDR5 6000 CL36的内存在AIDA64内存与缓存的成绩做一个演示，可以看到即使是4ch DDR5 6000MHz，在带宽以及延迟上都是远远不如缓存的。在带宽上，缓存都有着数倍于内存的水平，在延迟上缓存也是远好于内存，由此证明，缓存的存在依旧存在其价值。

​	现代计算机，常见的有冯诺依曼架构和哈佛架构。

​	冯诺依曼结构分为五大部分，内存、CPU、总线、输入设备、输出设备。

​	大多数CPU按照流水线的方式来执行指令。

1. 取指令

2. CPU 的 控制单元向 地址总线 发送 PC 中的地址，从内存中找到 待执⾏指令；
3. 并将 待执⾏指令 通过 数据总线 传⼊到 CPU 中的 指令ੀ存器 中
4. ⾃动更新 PC，指向下⼀条待执⾏指令的地址
5. 译指（分析指令）
6. CPU分析指令存器中的指令，确定指令的类型和参数：
1. 如果是计算类型的指令，就把指令交给逻辑运算单元运算;
2. 如果是存储类型的指令，则交由控制单元执⾏
7. 执⾏指令
8. 根据 译指的结果，把指令交给 CPU 中响应的控件（逻辑运算单元/控制单元）执⾏
9. 数据回写
10. CPU 将计算结果存回寄存器或者将寄存器的值存⼊内存

​	在冯·诺依曼架构之前还有一个哈佛架构，哈弗架构和冯·诺依曼架构最大的不同就是内存分为独立的指令内存和数据内存。因为指令内存的读取和数据内存的读写分开，一定程度上可以保证指令的连续性，不会因为需要访问内存上的数据造成指令堵塞。

### 	冯诺依曼瓶颈

​	冯·诺依曼瓶颈的概念最早由 John Backus 在 1977 年的图灵奖领奖演讲中提出： 由于 CPU 和存储器之间共享同一个系统总线，并且 CPU 和存储器之间存在巨大的速度差，导致 CPU 需要不断地被迫等待数据读取或写入到存储器，因此遏制了 CPU 的吞吐量 。

​	现代计算机体系采用优化策略来减弱冯·诺依曼瓶颈的影响，例如：

1、增加一个位于 CPU 和主内存之间的高速缓存

​	即L1、L2、L3三级缓存

​	也正是由于缓存的增加，CPU的运行不再像经典的冯诺依曼架构中直接操作内存，而是先把内存中的数据读到缓存，而内存的读和写操作会出现不一致的情况。

![image-20231121145857024](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211458088.png)

2、将指令缓存和数据缓存分离

​	在CPU-Z中可以看到L1缓存分为指令缓存和数据缓存，类似于哈佛架构中将指令与数据内存读写分离的设计。

![image-20231121135444162](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211354208.png)

## JMM定义

​	JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
原则:
​	JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的
能干嘛?
​	1 通过JMM来实现线程和主内存之间的抽象关系。
​	2 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。



### 可见性

​	是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即直到该变更，JMM规定了所有的变量都存储在主内存中。

![image-20231121152821316](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211528369.png)

​	每个线程读取变量时并不是直接操作主内存，而是先读取主内存，在该线程对应的本地内存中拷贝对应共享变量的副本，修改完后再写回主内存。

​	

> ​	这段话来自于JUC课程原文，感觉不够准确，没有细说线程变量副本何时写回。
>
> ​	系统主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“脏读”，所以每个线程都有自己的工作内存，线程自己的内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。
>
> ​	那么什么是线程脏读呢？
>

![image-20231121154256320](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211542380.png)

​	为了解决这种问题，我们要保证，修改的时候只有一个线程来改，修改后及时通知其他线程共享变量已更新。

### 原子性

​	指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰。

### 有序性

​	对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。

优缺点

​	JVM能根据处理器特性(CPU多级缓存系统、多核处理器等)适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致(即可能产生"脏读")，简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。

从源码到最终执行示例图：

​	![image-20231121155431416](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211554458.png)

单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。 

处理器在进行重排序时必须要考虑指令之间的数据依赖性。（例如int y = x * x一定要在int x = 0之后执行）

多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测。

## JMM规范下，多线程对变量的读写过程

​	由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，**但线程对变量的操作读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，探作完成后事将变量写回主内存**，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:

![image-20231121155827477](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211558535.png)

​	**JMM定义了线程和主内存之间的抽象关系**
1 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)，比如寄存器、L1、L2、L3缓存等)

2 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本(从硬件角度来说就是CPU的缓存

​	总结

- 我们定义的所有共享变量都储存在物理主内存中
- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)
- 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)
- 不同线程之间也无法直接访问其他线程的工作内存中的变是，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)

## 多线程先行发生原则之happens-before

![image-20231121160924463](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211609532.png)



![image-20231121161141895](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311211611970.png)

## happens-before总原则

- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
- 如果两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法

## happens-before之8条

从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：

1. 次序规则：**一个线程内**，按照代码的顺序，写在前面的操作先行发生于写在后面的操作，也就是说前一个操作的结果可以被后续的操作获取（保证语义串行性，按照代码顺序执行）。比如前一个操作把变量x赋值为1，那后面一个操作肯定能知道x已经变成了1
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作（后面指时间上的先后）。
3. volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样指时间上的先后
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。
5. 线程启动规则（Thread start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作
6. 线程中断规则（Thread Interruption Rule）：
   1. 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
   2. 可以通过Thread.interrupted()检测到是否发生中断
   3. 也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发生
7. 线程终止规则（Thread Termination Rule）：线程中的所有操作都优先发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。
8. 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize(）方法的开始------->对象没有完成初始化之前，是不能调用finalized()方法的

单线程次序、锁、volatile写操作一定发生在读操作之前、顺序传递规则

线程启动规则start先于此线程所有动作，线程中断规则interrupt在被isInterrupted发现被中断之前发生

线程终止规则线程所有操作先于对线程的终止检测



## happens-before小总结

在Java语言里面，Happens-before的语义本质上是一种可见性

A happens-before B ,意味着A发生过的事情对B而言是可见的，无论A事件和B事件是否发生在同一线程里

JVM的设计分为两部分：

  一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了

  另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提升性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序，我们只要关注前者就好了，也就是理解happens-before规则即可，其他繁杂的内容由JMM规范结合操作系统给我们搞定，我们只写好代码即可。

```JAVA
private int value =0;
public int getValue(){
    return value;
}
public int setValue(){
    return ++value;
}
```

问题描述：假设存在线程A和B，线程A先（时间上的先后）调用了setValue()方法，然后线程B调用了同一个对象的getValue()方法，那么线程B收到的返回值是什么？

答案：不一定

分析happens-before规则（规则5，6，7，8可以忽略，和代码无关）

1 由于两个方法由不同线程调用，不满足一个线程的条件，不满足程序次序规则

2 两个方法都没有用锁，不满足锁定规则

3 变量没有使用volatile修饰，所以不满足volatile变量规则

4 传递规则肯定不满足

综上：无法通过happens-before原则推导出线程A happens-before 线程B，虽然可以确定时间上线程A优于线程B，但就是无法确定线程B获得的结果是什么，所以这段代码不是线程安全的



注意：

- 如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证他们的有序性，虚拟机可以随意对他们进行重排序

如何修复？

- 把getter/setter方法都定义为synchronized方法------->不好，重量锁，并发性下降

```java
private int value =0;
public synchronized int getValue(){
    return value;
}
public synchronized int setValue(){
    return ++value;
}
```

- 把Value定义为volatile 变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景

```java
/**
* 利用volatile保证读取操作的可见性，
* 利用synchronized保证符合操作的原子性结合使用锁和volatile变量来减少同步的开销
*/
private volatile int value =0;
public int getValue(){
    return value;
}
public synchronized int setValue(){
    return ++value;
}
```

# Volatile



1. 内存屏障

   1. 阻止屏障两边的指令重排序

   2. 写数据时加入屏障，强制将线程私有工作内存的数据刷回主物理内存

      1. volatile写之前加入一个storestore屏障，禁止上面的普通写和下面的volatile写重排序，保证前面普通写的数据全部刷新到主内存中

         普通写和volatile写禁止重排，volatile写和volatile写禁止重排

      2. volatile写之后加入storeload屏障，禁止上面的volatile写和下面的volatile读写或普通写重排序，保证前面volatile写的操作，数据都已经全部刷新到主内存

         volatile写和普通写禁止重排，volatile写和volatile读/写禁止重排

   3. 读数据时加入屏障，线程私有工作内存数据失效，重新回到主物理内存获取最新数据

![image-20231123154802255](https://yingjun-typora.oss-cn-hangzhou.aliyuncs.com/img/202311231548367.png)